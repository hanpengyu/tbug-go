### sync.Mutex与sync.RWMutex

**竞态条件：**一旦数据被多个线程共享，那么就有可能产生争用和冲突的情况。
	
> 同步的用途有两个，一个是避免多个线程在同一时刻操作同一个数据块，另一个是协调多个线程，以避免它们在同一时刻执行同一个代码块。


只要一个代码片段需要实现对共享资源的串行化访问，就可以被视为一个临界区（critical section）。

#### 我们使用互斥锁（sync.Mutex）时有哪些注意事项？
* 不要重复锁定互斥锁；  
* 不要忘记解锁互斥锁，必要时使用  
* 不要对尚未锁定或者已解锁的互斥锁解锁；  
* 不要在多个函数之间直接传递互斥锁。

1、对一个已经锁定的互斥锁进行锁定，会立即阻塞当前的goruntine，直到该互斥锁的Unlock调用为止。（可能会导致多个goruntine竞争这把锁，会大大增加死锁的可能性）  
2、忘记解锁也会导致大量的goruntine等待，可能会导致所有用户级的goruntine等待，不过go是不会允许这种情况的，这个时候go系统会跑出panic，这个是无法恢复的。  （提醒一下，加锁之后可能会进入一个流程语句，这个时候的解锁语句最好是写到defer语句中）  
3、加锁和解锁要成对出现  
4、sync.Mutex是一个结构体类型，属于值类型中的一种，该类型是一个结构体类型，属于值类型中的一种。把它传给一个函数、将它从函数中返回、把它赋给其他变量、让它进入某个通道都会导致它的副本的产生

-

#### sync.RWMutex和sync.Mutex有哪些异同？

读写锁（sync.RWMutex）有如下的规则  
1、写锁已被锁定的情况下再试图锁定写锁，会阻塞当前的goroutine  
2、写锁已被锁定的情况下试图锁定读锁，也会阻塞当前的goruntine  
3、读锁已被锁定的情况下试图锁定写锁，同样会阻塞当前的goruntine  
**4、读锁已被锁定的情况下试图锁定读锁，不会阻塞当前的goruntine**

对写锁进行解锁，会唤醒“所有因为试图锁定读锁，而被阻塞的goroutine，并且他们都能成功完成对读锁的锁定，这也是上面第4条的意思”

读锁的解锁，需要在没有其他读锁锁定的情况下才会试图唤醒因为锁定写锁而被阻塞的goroutine，并且最后也只能只有一个能够成功的完成对写锁的锁定，至于是那一个，就要看那一个goruntine等待的时间最长了。

还有一点和互斥锁类似的地方，解锁“读写锁中未被锁定的写锁”，会立即引发panic，对于其中的读锁也是如此。


**用通俗易懂的话来总结一下：写锁的时候什么也不能干，读锁的时候不可以写，但是是可以读。**
  	


